# Let's Crack the Great(er) lapland monolith

### X-MAS CTF 2018, Web / Crypto [413, 451]

These are two versions of the same challenge, with the former also being solvable by bruteforcing (which is why the second challenge was added).

> "Psst, I got a task for you. There's this monolith to which I need to get access, but I can't get the numbers right. Can you help me? I pay well." ~ A shady dealer gnome

> "Hey, do you remember that monolith I had to get in last week? Now I stumbled upon something greater and shinier! Can you help me get access to this one?" ~ The same shady dealer gnome

The links both point to a website that allows us to guess numbers:

![The website for the first challenge](https://raw.githubusercontent.com/ClemensKnights/Writeups/master/xmasctf/lets-crack-the-great-lapland-monolith/images/great-monolith.png)

![The website for the second challenge after a wrong guess](https://raw.githubusercontent.com/ClemensKnights/Writeups/master/xmasctf/lets-crack-the-great-lapland-monolith/images/greater-monolith-wrong.png)

If we guess right, our streak counter increases (and presumably, guessing right often enough will get us the flag).

The title already hints at how to solve this problem - in the background, the random numbers are generated by an LCG pseudo-random number generator. Linear congruential generators are not particularly secure, and we can infer the state simply by observing a bunch of outputs.

We know that in an LCG, `s' = (a * s + k) mod m` for some parameters `a`, `k`, and `m`. To find `m`, we rely on the fact that for any state pair `s` and `t` (and their respective successors):

    s'  = (a * s + k) - x * m
    s'' = (a * a * s + (a + 1) * k) - (a * x + y) * m

    t'  = (a * t + k) - z * m

Then,

    s' - t   = (a * s + k - t) - x * m
    s' - t'  = a * (s - t) - (x + z) * m
    s'' - t' = (a * a * s + (a + 1) * k) - (a * x + y) * m - ((a * t + k) - z * m)
             = (a * (a * s - t) + a * k) - (a * x + y + z) * m
             = a * (a * s + k - t) - (a * x + y + z) * m

We form a matrix of `s - t`, `s' - t'`, `s' - t`, and `s'' - t'` and compute the determinant `D`,

    D = det([[s - t, s' - t], [s' - t', s'' - t']])
      = (s - t)(s'' - t') - (s' - t)(s' - t')
      = a * (s - t) * (a * s + k - t) - (a * x + y + z) * (s - t) * m
         - a * (s - t) * ((a * s + k - t) - x * m)
         - ((x + z) * m * ((a * s + k - t) - x * m))
      = - ax(s - t)m - y(s - t)m - z(s - t)m - ax(s - t)m - ...m

which is a multiple of `m`. Computing the GCD of a bunch of `D`s gives us a pretty good guess for `m`.

Once we have guessed `m`, we solve for `a` and `k`:

    a = (s' - s'') * modinv(s - s', m) mod m
    k = (s' - a * s) mod m

Then, we obtain another current state from the server and predict outputs until the server spits out the flags:

    X-MAS{LCG_0n_7h3_LapL4nd_m0n0LiTh_1s_n0t_7ha7_s3cur3}
    X-MAS{Bru73_F0rc3_1s_gr34t_bu7_LCG_1s_b3tt3r___}
